use crate::ast::{
  Expression, Literal, Operation, Pattern, Arm, Function, Enum, TopLevel, Program,
  Src,
};

grammar;

match {
  r"\s*" => {},
  r"[0-9]+",
  r"[a-zA-Z_]+",
  r"\(\*([^*]|\*+[^*/])*\*+\)" => {},
  _
}

Comma<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

pub Program: Program = <declarations:(<TopLevel>)+> => Program::new(declarations);

pub TopLevel: TopLevel = {
  <Enum> => TopLevel::Enum(<>),
  <Function> => TopLevel::Function(<>),
};

Enum: Enum = "enum" <name:Ident> ":=" <variants:Comma<VariantStr>> =>
  Enum {
    name: String::from(name),
    parameters: Vec::new(),
    variants: variants.into_iter().map(String::from).collect(),
  };

Function: Function = "let" <rec:"rec"?> <name:Ident> <parameters:Ident*> ":=" <body:Expression> =>
  Function {
    name: String::from(name),
    rec: rec.is_some(),
    parameters: parameters.into_iter().map(String::from).collect(),
    body,
  };

pub Pattern: Pattern = {
  <s:@L> <literal:Literal> <e:@R> => Pattern::Literal { literal, src: Src::new(s, e) },
  <s:@L> <variant:VariantStr> <e:@R> => Pattern::Variant { variant: String::from(variant), src: Src::new(s, e) },
  <s:@L> <name:Ident> <e:@R> => Pattern::Variable { name: String::from(name), src: Src::new(s, e) },
  <s:@L> "(" <binds:Comma<Ident>> ")" <e:@R> =>
    Pattern::Tuple { binds: binds.into_iter().map(String::from).collect(), src: Src::new(s, e) },
}

pub Expression: Expression = {
  <Infix>,
  <Fun>,
  <Let>,
  <If>,
  <Match>,
};

#[inline]
Fun: Expression = <s:@L> "fun" <variable:Ident> "->" <body:Expression> <e:@R> =>
  Expression::Fun { variable: String::from(variable), body: Box::new(body), src: Src::new(s, e) };

#[inline]
Let: Expression = <s:@L> "let" <bind:Ident> "=" <value:Expression> "in" <next:Expression> <e:@R> =>
  Expression::Let { bind: String::from(bind), value: Box::new(value), next: Box::new(next), src: Src::new(s, e) };

Arm: Arm = <left:Pattern> "=>" <right:Expression> => Arm { left, right };
#[inline]
Match: Expression = <s:@L> "match" <scrutinee:Expression> "with" <arms:("|" <Arm>)+> "end" <e:@R> =>
  Expression::Match { scrutinee: Box::new(scrutinee), arms, src: Src::new(s, e) };

#[inline]
If: Expression = <s:@L> "if" <condition:Expression> "then" <then:Expression> "else" <otherwise:Expression> <e:@R> =>
  Expression::If { condition: Box::new(condition), then: Box::new(then), otherwise: Box::new(otherwise), src: Src::new(s, e) };

Infix: Expression = {
  #[precedence(level="0")]
  <Application>,

  #[precedence(level="1")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "*" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Mul, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="1")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "/" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Div, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="2")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "-" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Sub, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="2")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "+" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Add, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="3")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> ">" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Gt, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="3")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> ">=" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Gte, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="4")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "<" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Lt, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="4")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "<=" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Lte, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="5")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "=" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Eq, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="5")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "<>" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Neq, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },

  #[precedence(level="6")] #[assoc(side="left")]
  <s:@L> <lhs:Infix> "++" <rhs:Infix> <e:@R> =>
    Expression::BinaryOp { op: Operation::Concat, lhs: Box::new(lhs), rhs: Box::new(rhs), src: Src::new(s, e) },
}

Application: Expression = {
  <SubExpression>,
  <s:@L> <function:Application> <argument:SubExpression> <e:@R> =>
    Expression::Application { function: Box::new(function), argument: Box::new(argument), src: Src::new(s, e) },
}

pub SubExpression: Expression = {
  <Primary>,
  "begin" <Expression> "end",
  "(" <Expression> ")",
  <s:@L> "(" ")" <e:@R> => Expression::Unit { src: Src::new(s, e) },
  <s:@L> "(" <mut elements:(<Expression> ",")+> <last:Expression?> ")" <e:@R> => match last {
    Some(last) => {
      elements.push(last);
      Expression::Tuple { elements, src: Src::new(s, e) }
    },
    None => Expression::Tuple { elements, src: Src::new(s, e) },
  },
};

pub Primary: Expression = {
  <s:@L> <literal:Literal> <e:@R> => Expression::Literal { literal, src: Src::new(s, e) },
  <Variant>,
  <Hole>,
  <Variable>,
};

pub Literal: Literal = {
  "true" => Literal::Boolean { value: true },
  "false" => Literal::Boolean { value: false },
  <StringLiteral> => Literal::String { value: <> },
  <r"[0-9]+"> => Literal::Number { value: <>.parse::<i32>().unwrap() },
};

pub Variant: Expression = <s:@L> <variant:VariantStr> <e:@R> =>
  Expression::Variant { variant: String::from(variant), src: Src::new(s, e) };
pub Hole: Expression = <s:@L> "?" <ident:Ident> <e:@R> =>
  Expression::Hole { name: String::from(ident), src: Src::new(s, e) };
pub Variable: Expression = <s:@L> <ident:Ident> <e:@R> =>
  Expression::Variable { name: String::from(ident), src: Src::new(s, e) };

StringLiteral: String = r#""([^"\\]|\\.)*""# => String::from(<>.trim_matches('"'));

pub VariantStr: &'input str = "." <s:r"[a-zA-Z_]+"> => s;
pub Ident: &'input str = <s:r"[a-zA-Z_]+"> => s;
